{"version":3,"sources":["components/Map.tsx","components/WelcomeModal.js","App.js","serviceWorker.js","index.js"],"names":["point_in_polygon","point","vs","x","y","inside","i","j","length","xi","yi","xj","yj","area","coords","interior","Topojson","MultiPolygonEnhanced","multi_polygon","type","coordinates","enhanced_coordinates","map","polygon","PolygonShape","this","bboxes","polygon_coors","get_bbox","Math","min","bbox","max","get_area","reduce","acc","some","in_region","target_area","subregion","subregion_piece","get_subregion","push","xs","cur","ys","slice","coors","inside_external_border","in_a_hole","coor","newpoint","lower","upper","fix_winding","get_subcoordinates","ceil","npoints","reverse","Array","PolygonEnhanced","EUGeojson","geojson","features","features_obj","parse_features","features_with_bbox","feature","geometry","features_with_areas","properties","topojson","topo_geometries","objects","NUTS_RG_01M_2021_4326","geometries","neighbors_arr","ids_in_topojson","id","features_with_neighbors","idx_in_topojson","findIndex","neighbors","in_polygon","filter","in_bbox","console","log","eu_geojson","compute_bboxes","compute_areas","hook_neighbors","geometry_parser","MyMap","props","cities","onClick","e","latlng","lng","lat","point_city","point2region","painted_cities","initial_city","pushed_candidates","candidates","total_area","painted_cities_ids","candidate_idxs","city","idx","arr","cur2","cand_idx","includes","sort","a","b","candidate","smaller_candidate","subregion_coordinates","fill_area","setState","current","leafletElement","flyTo","animate","duration","state","Cities_topojson","Cities_topojson_raw","from_topojson","React","createRef","Map","center","zoom","style","width","height","ref","onclick","TileLayer","attribution","url","GeoJSON","data","stroke","color","Component","Modal","setAppElement","customStyles","content","top","bottom","transform","borderRadius","overlay","zIndex","backgroundColor","WelcomeModal","isopen","isOpen","onRequestClose","contentLabel","textAlign","fontSize","marginTop","ReactGA","initialize","pageview","App","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.33f9cfa8.chunk.js","sourcesContent":["import React, { Component } from 'react'\nimport { Map, TileLayer, Marker, Popup, GeoJSON} from 'react-leaflet'\nimport {LeafletMouseEvent } from 'leaflet'\nimport 'leaflet/dist/leaflet.css';\nimport * as Topojson from \"topojson\";\nimport {Topology, GeometryCollection} from \"topojson-specification\"\nimport Cities_topojson_raw from './NUTS_RG_01M_2021_4326_LEVL_3.json'\nimport {\n  FeatureCollection, \n  Feature, \n  GeometryObject,\n  Polygon, \n  MultiPolygon,\n  BBox,\n  Position\n} from 'geojson'\n\n// Properties in TopoJson plus a few we add\ninterface Properties {\n  NUTS_ID: string,\n  LEVL_CODE: number,\n  CNTR_CODE: string,\n  NAME_LATN: string,\n  NUTS_NAME: string,\n  MOUNT_TYPE: string | null,\n  URBN_TYPE: string | null,\n  COAST_TYPE: string | null,\n  FID: string,\n  neighbors?: number[],\n  area?: number\n}\n\n//Custom Type for TopoJson\ntype EU_topology = Topology<{\n  NUTS_RG_01M_2021_4326: GeometryCollection<Properties>\n}>\n\ninterface EnhancedGeometries<T extends GeometryTypes>{\n  get_bbox(): [number, number, number, number]\n  get_area(): number\n  in_region(point:[number, number]): boolean,\n  get_subregion(target_area:number): T['coordinates'] | null\n}\n\ntype GeometryTypes = Polygon | MultiPolygon\ntype EnhancedGeometryTypes = PolygonEnhanced | MultiPolygonEnhanced\n\nfunction point_in_polygon(point:[number, number], vs: Position[]) {\n  // ray-casting algorithm based on\n  // http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html\n  \n  var x = point[0], y = point[1];\n  \n  var inside = false;\n  for (var i = 0, j = vs.length - 1; i < vs.length; j = i++) {\n      var xi = vs[i][0], yi = vs[i][1];\n      var xj = vs[j][0], yj = vs[j][1];\n      \n      var intersect = ((yi > y) != (yj > y))\n          && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);\n      if (intersect) inside = !inside;\n  }\n  \n  return inside;\n};\n\nfunction area(coords:Position[], interior:boolean){\n  return Topojson.sphericalRingArea(coords as Array<[number, number]>, interior) * 6371**2\n}\n\nfunction fill_area(\n  cities:EUGeojson, \n  initial_city: Feature<EnhancedGeometryTypes, Properties>,\n  target_area: number){\n\n  let pushed_candidates:Array<Feature<EnhancedGeometryTypes, Properties>> = []\n  const painted_cities = []\n  let candidates = [initial_city]\n  let total_area = 0\n\n  //Deals with initial city\n\n  if(candidates[0].properties.area as number < target_area){\n    painted_cities.push(candidates[0])\n    total_area += candidates[0].properties.area as number\n    pushed_candidates.push(candidates[0])\n  }\n\n  //Deals with neighbors\n  while (pushed_candidates.length > 0){\n    //populate candidates\n    let painted_cities_ids = painted_cities.map(cur=>cur.id)\n    const candidate_idxs = pushed_candidates\n      .reduce((acc, city, idx, arr)=>([...acc, ...(city.properties.neighbors as number[])]), [] as number[] )\n      .filter((cur, idx, arr)=>arr.findIndex(cur2=>cur2==cur)==idx) // remove duplicates\n      \n    candidates = candidate_idxs\n      .map(cand_idx=>cities.features[cand_idx])\n      .filter(city=>!painted_cities_ids.includes(city.id))\n       \n    //calculate area for candidates\n    candidates = candidates.sort((a, b) => ((b.properties.area as number) - (a.properties.area as number)))\n    //Try to push candidates\n    pushed_candidates = []\n    for (let candidate of candidates){\n      if (total_area + (candidate.properties.area as number) <= target_area){\n        painted_cities.push(candidate)\n        total_area += candidate.properties.area as number\n        pushed_candidates.push(candidate)\n      } \n    }\n  }\n  //Deals with incomplete neighbor to fill the remaining gap\n  if (candidates.length == 0){\n     // there are no candidates. That happens in islands. \n     //TODO: handle islands\n  } else {\n    const smaller_candidate = candidates[candidates.length - 1]\n    const subregion_coordinates = smaller_candidate.geometry.get_subregion(target_area - total_area)\n    if(subregion_coordinates != null){\n      const subregion:Feature<EnhancedGeometryTypes, Properties> = {\n        ...smaller_candidate,\n        geometry: EUGeojson.geometry_parser({\n          ...smaller_candidate.geometry,\n          //@ts-ignore\n          coordinates:subregion_coordinates\n        })\n      }\n      subregion.properties.area = subregion.geometry.get_area()\n      painted_cities.push(subregion)\n    }\n  } \n  return painted_cities\n\n}\n\n\nclass MultiPolygonEnhanced implements MultiPolygon, EnhancedGeometries<MultiPolygon>{\n  type: \"MultiPolygon\";\n  coordinates\n  constructor(multi_polygon: MultiPolygon){\n    const {type, coordinates} = multi_polygon\n    const enhanced_coordinates = coordinates.map(polygon=>new PolygonShape(...polygon))\n    this.type = type\n    this.coordinates = enhanced_coordinates\n  }\n\n  get_bbox(){\n    const coordinates = this.coordinates\n    const bboxes = coordinates.map(polygon_coors => polygon_coors.get_bbox())\n    const bbox:[number, number, number, number] = [\n      Math.min(...bboxes.map(bbox=>bbox[0])),\n      Math.max(...bboxes.map(bbox=>bbox[1])),\n      Math.min(...bboxes.map(bbox=>bbox[2])),\n      Math.max(...bboxes.map(bbox=>bbox[3]))\n    ]\n    return bbox\n  }\n  \n  get_area(){\n    const coordinates = this.coordinates\n    const area = coordinates\n      .map(polygon_coors=>polygon_coors.get_area())\n      .reduce((acc, area)=>acc + area, 0)\n    return area\n  }\n\n  in_region(point:[number, number]){\n    const coordinates = this.coordinates\n    const in_any_polygon = coordinates.some(polygon_coors => polygon_coors.in_region(point))\n    return in_any_polygon\n  }\n\n  get_subregion(target_area:number){\n    const coordinates = this.coordinates\n    let acc_area = 0\n    const subregion = []\n    for(let polygon_coors of coordinates){\n      const subregion_piece = polygon_coors.get_subregion(target_area - acc_area)\n      if(subregion_piece == null){\n        //smallest region bigger that target\n        break\n      } else {\n        subregion.push(subregion_piece)\n        if(subregion_piece.length < polygon_coors.length){\n          //search hit target\n          break\n        }\n      }\n    }\n    return subregion.length == 0 ? null : subregion\n  }\n\n}\n\nclass PolygonShape extends Array<Position[]>{\n  \n  get_bbox(){\n    const polygon = this\n    const coordinates = polygon[0] // coordinates of external border\n    const xs = coordinates.map(cur=>cur[0])\n    const ys = coordinates.map(cur=>cur[1])\n    const bbox: [number, number, number, number] = [\n      Math.min(...xs), \n      Math.max(...xs),\n      Math.min(...ys), \n      Math.max(...ys),\n    ]\n    return bbox\n  }\n\n  get_area(){\n    const polygon = this\n    const outer_area = area(polygon[0], false)\n    const hole_area = polygon.slice(1).map(coors=>area(coors, true)).reduce((acc, area)=>acc + area, 0)\n    return outer_area - hole_area\n  }\n\n  in_region(point:[number, number]){\n    const polygon = this\n    const inside_external_border = point_in_polygon(point, polygon[0])\n    if (inside_external_border == true && polygon.length > 1){\n      const in_a_hole = polygon.slice(1).some(coor => point_in_polygon(point, coor))\n      return inside_external_border && !in_a_hole\n    } else {\n      return inside_external_border\n    }\n  }\n\n  get_subregion(target_area:number){\n    const polygon = this\n    const coordinates = polygon[0]\n    let lower = 3\n    let upper = coordinates.length\n    let newpoint\n\n    if(area(\n        PolygonShape.fix_winding(\n          PolygonShape.get_subcoordinates(coordinates, lower)), \n        false\n      ) > target_area){\n      return null\n    }\n    while (lower != upper - 1){\n      // binary search\n      newpoint = Math.ceil((lower + upper)/2)\n      if(area(\n        PolygonShape.fix_winding(\n            PolygonShape.get_subcoordinates(coordinates, newpoint)), \n            false\n          ) > target_area){\n        upper = newpoint\n      } else {\n        lower = newpoint\n      }\n    }\n    return [PolygonShape.fix_winding(PolygonShape.get_subcoordinates(coordinates, lower))]\n  }\n\n  static get_subcoordinates(coordinates:Position[], npoints:number){\n    return [...coordinates.slice(0, npoints), coordinates[0]]\n  }\n\n  static fix_winding(coordinates: Position[]){\n    if(area(coordinates, false)<510e6/2){\n      return coordinates\n    } else {\n      return coordinates.reverse()\n    }\n  }\n\n}\n\nclass PolygonEnhanced implements Polygon, EnhancedGeometries<Polygon>{\n  type: \"Polygon\";\n  coordinates\n  constructor(multi_polygon: Polygon){\n    const {type, coordinates} = multi_polygon\n    this.type = type\n    this.coordinates = new PolygonShape(...coordinates)\n  }\n\n  get_bbox(){\n    const coordinates = this.coordinates\n    return coordinates.get_bbox()\n  }\n\n  get_area(){\n    const coordinates = this.coordinates\n    return coordinates.get_area()\n  }\n\n  in_region(point:[number, number]){\n    const coordinates = this.coordinates\n    return coordinates.in_region(point)\n  }\n\n  get_subregion(target_area: number){\n    const coordinates = this.coordinates\n    return coordinates.get_subregion(target_area)\n  }\n}\n\nclass EUGeojson implements FeatureCollection<EnhancedGeometryTypes, Properties>{\n  type;\n  features;\n  constructor(geojson: FeatureCollection<GeometryObject, Properties>){\n    const {type, features} = geojson\n    const features_obj = EUGeojson.parse_features(features)\n    this.type = type\n    this.features = features_obj\n  }\n\n  static from_topojson(topojson: EU_topology){\n    const geojson: FeatureCollection<\n      GeometryObject, \n      Properties\n    > = Topojson.feature(\n      topojson, \n      topojson.objects.NUTS_RG_01M_2021_4326)\n    const eu_geojson = new EUGeojson(geojson)\n    eu_geojson.compute_bboxes()\n    eu_geojson.compute_areas()\n    eu_geojson.hook_neighbors(topojson)\n    return eu_geojson\n  }\n  static geometry_parser(geometry: Polygon): PolygonEnhanced\n  static geometry_parser(geometry: MultiPolygon): MultiPolygonEnhanced \n  static geometry_parser(geometry: GeometryObject): EnhancedGeometryTypes\n  static geometry_parser(geometry: GeometryObject): EnhancedGeometryTypes{\n    if (geometry.type == 'Polygon'){\n      return new PolygonEnhanced(geometry)\n    } else if (geometry.type == 'MultiPolygon'){\n      return new MultiPolygonEnhanced(geometry)\n    } else {\n      throw \"error\"\n    } \n  }\n  static parse_features(features: Array<Feature<GeometryObject, Properties>>){\n    return features.map((feature:Feature<GeometryObject, Properties>): Feature<EnhancedGeometryTypes, Properties> => {\n      const { geometry } = feature\n      return {\n        ...feature,\n        geometry: EUGeojson.geometry_parser(geometry)\n      }\n    })\n  }\n\n  compute_bboxes(){\n    const features = this.features\n    const features_with_bbox = features.map(feature=>({\n      ...feature,\n      bbox: feature.geometry.get_bbox()\n    }))\n    this.features = features_with_bbox \n  }\n\n  compute_areas(){\n    const features = this.features\n    const features_with_areas = features.map(feature=>({\n      ...feature,\n      properties:{\n        ...feature.properties,\n        area: feature.geometry.get_area()\n      } \n    }))\n    this.features = features_with_areas\n  }\n\n  hook_neighbors(topojson: EU_topology){\n    const features = this.features\n    const topo_geometries = topojson.objects.NUTS_RG_01M_2021_4326.geometries\n    const neighbors_arr = Topojson.neighbors(topo_geometries)\n    const ids_in_topojson = topo_geometries.map(geometry=>geometry.id)\n    const features_with_neighbors = features.map(feature=>{\n      const idx_in_topojson = ids_in_topojson.findIndex(id => id==feature.id)\n      if (idx_in_topojson == -1){\n        throw 'cannot find reference in topojson'\n      }\n      const neighbors = neighbors_arr[idx_in_topojson]\n      return {\n        ...feature,\n        properties:{\n          ...feature.properties,\n          neighbors: neighbors\n        }\n      }\n    })\n    this.features = features_with_neighbors\n  }\n  \n  in_bbox(\n    point:[number, number], \n    bbox?: BBox){\n    const [x, y] = point\n    if(!!bbox){\n      return (\n        (bbox[0]<x) && (x<bbox[1]) &&\n        (bbox[2]<y) && (y<bbox[3]))\n    } else {\n      throw 'no bbox'\n    }\n  }\n\n  point2region(x:number, y:number){\n    const features = this.features\n    const in_bbox = features.filter(feature=>this.in_bbox([x, y], feature.bbox))\n    const in_polygon = in_bbox.filter(feature=>feature.geometry.in_region([x, y]))\n    if (in_polygon.length > 1){\n      console.log('Warning, more than 2 polygons match the point: ', [x, y])\n    }\n    return in_polygon[0]\n  }\n}\n\ninterface State{\n  painted_cities: Array<Feature<EnhancedGeometryTypes, Properties>> | null\n}\n\nexport default class MyMap extends Component<{}, State> {\n  cities: EUGeojson\n  map: React.RefObject<Map>\n  constructor(props:{}){\n    super(props)\n    this.state = {\n      painted_cities: null\n    }\n    const Cities_topojson: EU_topology = Cities_topojson_raw as EU_topology\n    this.cities = EUGeojson.from_topojson(Cities_topojson)\n    this.map = React.createRef()\n  }\n  \n\n  onClick = (e:LeafletMouseEvent) => {\n    const cities = this.cities\n\n    const {lng, lat} = e.latlng\n    \n    const point_city = cities.point2region(lng, lat)\n    if (point_city){\n      const painted_cities = fill_area(cities, point_city, 23000) \n\n      this.setState({painted_cities}, ()=>{\n        //TODO: zoom on bound box of the painted region, not on the selected point\n        if (!!this.map.current){\n          this.map.current.leafletElement.flyTo({lng, lat}, 7.5, {\n            animate: true,\n            duration: 1\n          })\n        }\n      })\n    } \n  }\n\n  render() {\n    const {painted_cities} = this.state\n    return (\n      <Map \n        center={{\n          lat: 39.805131330469024,\n          lng: -8.004303136599654,\n        }} \n        zoom={5} \n        style={{ width: '100%', height: '100%',}}\n        ref={this.map}\n        onclick={this.onClick}\n      >\n      <TileLayer\n        attribution='&copy <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors | &copy EuroGeographics for the administrative boundaries'\n        url=\"https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png\"\n        />\n      {painted_cities !== null && \n        <GeoJSON \n          key={painted_cities.map(cur=>cur.id).reduce((acc, cur)=>acc as string+cur, '')} \n          data={painted_cities} \n          style={{stroke: false, color:'#f00'}}/>}\n      </Map>\n    )\n  }\n}","import React, { Component } from 'react'\nimport ReactDOM from 'react-dom';\nimport Modal from 'react-modal';\n\nModal.setAppElement('#root');\n\nconst customStyles = {\n  content : {\n    top                   : '50%',\n    // left                  : '50%',\n    // right                 : 'auto',\n    bottom                : 'auto',\n    // marginRight           : '-50%',\n    transform             : 'translate(0%, -50%)',\n    borderRadius: '20px'\n  },\n  overlay: {\n    zIndex: 1000,\n    backgroundColor: 'rgba(255, 255, 255, 0.75)'\n  }\n};\n\nexport default class WelcomeModal extends Component {\n  constructor(props){\n    super(props)\n    this.state = {isopen: true}\n  }\n  render(){\n    return (\n      <Modal\n        isOpen={this.state.isopen}\n        onRequestClose={()=>this.setState({isopen:false})}\n        style={customStyles}\n        contentLabel=\"Example Modal\"\n      >\n        <h2 style={{textAlign: 'center'}}>E se fosse lá em casa?</h2>\n        <p style={{textAlign: 'justify'}}>\n          Placeholder\n        </p>\n        <p style={{textAlign: 'right', fontSize:'small', marginTop: '30px'}}>Encontrou um Bug? Nos ajude reportando-o em placeholder@gmail.com</p>\n      </Modal>\n    )\n  }\n}\n","import React, { Component, Fragment } from 'react';\n// import axios from 'axios';\nimport Map from './components/Map'\nimport WelcomeModal from './components/WelcomeModal'\nimport ReactGA from 'react-ga';\n\nReactGA.initialize('UA-179640894-1');\nReactGA.pageview('/homepage');\n\nclass App extends Component {\n  render() {\n    return (\n      <div style={{ width: '100%', height: '100%',}}>\n        <WelcomeModal/>\n        <Map/>\n      </div>\n      \n    );\n  }\n }\n export default App;","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}